---
title: 解码方法
date: 2019-07-22
categories:
    - 算法
    - 动态规划
tags:
    - leetcode
---

[查看 leetcode - 091 - 解码方法](https://leetcode.com/problems/decode-ways/ "leetcode - 091 - 解码方法")

### 题目

一条包含字母 A-Z 的消息通过以下方式进行了编码：

'A' -> 1
'B' -> 2
...
'Z' -> 26
给定一个只包含数字的非空字符串，请计算解码方法的总数。

示例 1:

输入: "12"
输出: 2
解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
示例 2:

输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。

<!-- more -->

### 解题思路

审题 非空字符串 是对1-26数字解码并不包括单独的一个0

使用动态规划来解决问题

假设当前字符在字符串中的下标为i

dp[i]表示s[i]之前的字符解码的情况数量

例如dp[3]代表s[3]之前，也就是s[0] s[1] s[2]三个字符组合的解码数量

先看一个例子 "12321"

则
dp[1] = 1 // 1
dp[2] = 2 // 12
dp[3] = 3 // 123

理解起来

123的组合数目 = `dp[i-1]`上次结果(如果当前值不为0，当前值是3) + `dp[i-2]`上上次结果(如果当前数字与上一位数字可以组成有效数字 23) = dp[2] + dp[1] = 3

即

初始dp[i]为0
`dp[i]=0`

如果当前数字无效
`dp[i] = 0`
如果当前数字前一个数字与当前数字组合也无效
`return 0`

如果当前数字有效，则到当前数字的解码数增加前一个数字解码的数量
`dp[i] += dp[i-1]`

如果当前数字与前一个数字可以组成有效数字，并且当前数字与上一个数字可以组成有效数字，则当前数字解码数增加前前一个数字的解码数量
`dp[i] += dp[i-2]`

### 完整代码

```go
func NumDecodings091(s string) int {
	if s[0] == '0' {
		return 0
	}

	l := len(s)

	if l == 1 {
		return 1
	}

	dp := make([]int, l+1)
	dp[0] = 1

	for i := 1; i <= l; i++ {
		if s[i-1] == '0' {
			dp[i] = 0
			if s[i-2] < '1' || s[i-2] > '2' {
				return 0
			}

		} else {
			dp[i] = dp[i-1]
		}

		if i-1 > 0 && ((s[i-2] == '1') || (s[i-2] == '2' && s[i-1] <= '6')) {
			dp[i] += dp[i-2]
		}
	}

	return dp[l]
}
```
