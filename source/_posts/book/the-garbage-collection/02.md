---
title: 《垃圾回收算法手册》 标记-清扫算法
date: 2019-05-13
updated: 2019-05-17
categories:
    - 读书笔记
tags:
    - 《垃圾回收算法手册》
---

## 标记-清扫算法

赋值器线程在工作过程中，会执行三种与回收器相关的操作

- 创建(New)
  `New()` New操作从堆分配器中获得一个新的堆对象，分配器还会返回新分配对象的首地址。在默认情况下，New操作的定义是简单的执行内存分配操作。

    ```
    New():
      return allocate()
    ```

- 读(Read)
  `Read(src, i)` Read操作访问内存中的某一对象的域，并返回该域所记录的值，其中保存的既可以是纯值，也可以是指针。其中`src`和`i`分别为指向对象的指针和待访问的域的索引号。在默认情况下，Read的的定义是简单的返回域内容。

    ```
    Read(src, i):
        return src[i]
    ```

- 写(Write)
  `Write(src, i, val)` Write操作改变特定内存的值。其中`src`、`i`和`val`分别为指向源对象的指针、待修改域的索引号、待存储的值（纯值或指针）。默认情况下，Write操作的定义是简单的更新域。

    ```
    Write(src, i, val)
        src[i] <- val
    ```

简单的讲，标记-清扫算法分为三步进行

1. 分配
2. 标记
3. 清扫

### 分配

标记-清扫算法与赋值器之间的接口非常简单：如果线程无法分配对象，则唤起回收器，然后再次尝试分配。如果回收完成之后依然没有足够的内存分配需求，则说明堆内存耗尽。

其中我们用`atomic`标记说明`collect`在此处视为一个原子操作，表示回收器是在"万物静止"模式下而非与赋值器线程并发执行。

```
New():
    ref <- allocate()  // 尝试分配内存
    if ref == null  // 无法分配内存
        collect()  // 进行垃圾回收
        ref <- allocate()  // 再次尝试分配内存
        if ref == null // 无法分配内存
            error "Out of memory" // 抛出异常，内存耗尽
    return ref // 返回分配的内存空间

atomic collect():
    markFromRoots() // 标记
    sweep(HeapStart, HeapEnd) // 清扫
```

### 标记

回收器在遍历对象图之前必须县构造标记过程中需要用到的起始工作列表(worklist)，即对每个根对象进行标记并将其加入工作列表。

回收器可以通过设置对象头部某个位（或字节）的方式对其进行标记。

不包含指针的对象不会有任何后代，所以不需要加入到工作列表中，但也需要进行标记。

基本标记流程：从工作列表中获取一个对象引用，然后对其所引用的其他对象进行标记，指导工作列表变空。

```
markFromRoots():
    initialise(worklist)
    // 遍历根对象，标记并将其加入工作列表
    for each fld in Roots
        ref <- *fld
        // 对不为空&&未标记的引用进行标记，并添加到工作列表中
        if ref != null && not isMarked(ref)
            setMarked(ref)
            add(worklist, ref)

            // 对工作列表中的对象（根）进行标记处理
            // 每处理一个根立马处理可以保证worklist大小不会太大
            // 如果将其从循环中提出，则可加快线程根扫描
            // 部分回收器可以在之后的对象图遍历过程中，与赋值器并发进行。
            mark()

initialise(worklist):
    worklist <- empty

mark():
    // 处理工作列表中所有的对象
    // 标记阶段的完成标志是工作表为空
    while not isEmpty(worklist)
        // 从工作列表中移除一个对象
        // 并对其内部存放的其他地址的指针进行处理
        ref <- remove(worklist)

        // 遍历引用中指向其他地方的所有指针
        for each fld in Pointers(ref)
            child <- *fld

            // 对不为空&&未标记的引用进行标记，并添加到工作列表中
            if child != null && not isMarked(child)
                setMarked(child)
                add(worklist, child)
```

单线程回收器可以基于栈来实现工作列表，此时回收器将以深度优先顺序遍历对象图。



### 清扫

在清扫阶段，回收器会将所有未标记的对象返还给分配器。在这过程中，回收器通常会在堆中进行线性扫描，同事清空存活对象的标记位以便下次使用。

```
sweep(start, end):
    scan <- start
    while scan < end
        // 如果标记了，则取消标记
        // 如果未标记，则释放空间
        if isMarked(scan)
            unsetMarked(scan)
        else
            free(scan)
        scan <- nextObject(scan)
```

至此回收完成。但是需要注意的是，标记-清扫回收器要求堆不具满足一定条件:

1. 标记-清扫回收器不会移动对象，因此内存管理器必须能够控制堆内存碎片。因为过多碎片可能会导致分配器无法满足新分配请求，从而增加垃圾回收频率，或者新对象的分配根本无法完成。

2. 清扫器`sweep`必须能够遍历堆中每个对象，对于给定对象，不管其后是否存在一些用于对齐的填充字节，`sweep`方法都必须能够找到下一个对象，因此用`nextObject`方法要完成堆的遍历，仅仅获取对象的大小是远远不够的，因为后面可能会有填充字节。

## 改进的标记-清扫算法

程序的性能通常与其高速缓存的相关行为有很大关系。之所以高速缓存可以提升程序性能，是因为程序在运行时表现出了良好的时间局部性和空间局部性。

`时间局部性`，程序在访问了某个内存地址后，很可能在不久之后再次访问该地址，因此值得将它缓存。

`空间局部性`，程序在访问了某个内存地址后，很可能在不久之后访问该地址附近的数据，因此预读附近数据。

未改进的标记-清扫算法将标记放在对象头部，但这样性能会比较差

1. 大部分对象在标记阶段通常只会读写对象头部各一次，即回收器读取对象头部的标记位，如果尚未标记过则设置其标记位。对于将标记位放置在对象头部的策略，由于堆中对象在标记阶段往往只会访问一次，所以硬件预取无法发挥功效。

2. 高速缓存与内存之间的交互不是以单个字节为单位的，是以缓存行为单位的，通常是 32 ~ 128 个字节。当高速缓存失效后需要回写到内存里，那么就算只改了一个字节，也需要回写整个缓存行。

3. 如果回收器线程和赋值器线程并发执行，也会有线程安全的问题。

### 位图标记

使用一个独立的位图来维护标记位。位图中每个位关联堆中每个可能分配对象的地址。

位图标记通常只适用于单线程环境，因为多线程同时修改位图会存在写冲突。

使用位图的好处

1. **标记位更加密集。**
2. **标记过程只需要读取存活对象的指针域而不会修改任何对象。**
3. **清扫器不会对存活对象进行任何读写操作，它只会在释放垃圾对象的过程中覆盖其某些域，例如将它连接到空闲链表上。**所以位图标记不仅可以减少内存中需要修改的字节数，而且减少了对高速缓存行的写入，进而减少需要写回内存的数据量。
4. **减少回收过程的内存换页次数**。许多证据表明，对象往往成簇出现，成簇死亡，而许多分配器往往也会将这些对象分配在相邻空间。
    1.在位图/字节图中，每个位或者每个字节全部都被设置/清空标记位的情况经常出现，因此回收器可以批量读取/清空一批对象的标记位。
    2.通过位图可以更简单的判定某一个内存块中的所有对象是否都是垃圾，进而可能一次性回收整个内存块。

### 混合标记策略

将每一个数据块与字节图中的一个字相关联，同时依然保留对象头部的标记位。

当且仅当内存块中至少存在一个存活对象时，该内存块所对应的标记字节才会被设置。

所以清扫器可以根据字节图快速的判断某一个内存块是否完全为空，进而整体回收。
