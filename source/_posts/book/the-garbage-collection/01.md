---
title: 《垃圾回收算法手册》 第一章 引言
date: 2019-05-05
updated: 2019-05-06
categories:
    - 读书笔记
tags:
    - 《垃圾回收算法手册》
---

### 显式内存释放的弊端

1. 过早回收依然在引用的对象，引发`悬挂指针`问题。
2. 使用对象完毕之后未将对象释放，引发`内存溢出`问题。

<!-- more -->

#### 悬挂指针

正常情况下，开发者将不会访问已经释放的内存，所以运行时系统将其清空（填充0），也可以将其重新分配出去，甚至可以可以归还给操作系统。因此，如果程序对悬挂指针进行访问，那么结果不可预知。最好结果是程序立即崩溃，但是更常见的是崩溃前再运行一段时间或者一直运行下去但是输出错误的结果（比如读取指针指向的内容时读取到错误的内容）。

检测悬挂指针的一种策略是使用`肥指针`，他将指针目标对象的版本号作为指针本身的一部分。在对肥指针进行解引用时，运行系统首先判断肥指针中记录的版本号与其目标的版本号是否一致。这一方法存在额外开销，而且并非完全可靠，因此应用范围几乎仅限于调试工具上。

#### 内存溢出

对于小型应用程序影响有限，但是对于大型、长时间运行程序会造成极大影响甚至崩溃。而且部分内存溢出问题只有在长时间运行才会逐渐显露出来，查错、调试不易。

对象的存活性是一个全局特征，但是调用free函数将其释放是一个局部行为，所以如何将对象正确释放是一个很复杂的问题。

#### 其他问题

开发者需要更多的精力来关注内存问题。

尽管C++在这方面进行了一些尝试和努力，但仍有一定的限制。

### 自动动态内存管理

可以解决大多数悬挂指针和内存泄露的问题。垃圾回收可以将未被任何可达对象引用的对象回收，从而避免悬挂指针的出现。原则上讲可以，`回收器`最终都会将所有不可达对象回收，但是有两个注意事项：

1. `追踪式回收`引入“垃圾”这一有明确判定标准的概念，并不一定包含所有不再使用的对象。

2. 在实际情况下，出于效率原因，某些对象可能不会被回收。

#### 回收器

回收器中掌握堆中对象的全局信息以及所有可能访问堆中对象的线程信息，因而可以决定任意对象是否需要回收。显式释放的主要问题在于无法在局部上下文中掌握全局信息，而自动动态内存管理则简单的解决了这一个问题。

由于只有回收器可以释放对象，所以不会出现二次释放的问题。

#### 并非银弹

虽然垃圾回收可以解决悬挂指针问题，但是对于那种一直可达但无限增长的数据结构，依然无能为力。

### 垃圾回收算法之间的比较标准

不同的垃圾回收器在不同的工作负载、硬件环境以及性能要求下都有不同的表现，没有哪种回收器能保证在所有情况下都表现最优。

在对垃圾回收器进行参数调优时，一方面的提升就可能导致其他方面的下降。

#### 安全性

垃圾回收器首要考虑的因素是安全。任何情况下都不能将存活的对象回收。

#### 吞吐量

对于最终用户来讲，程序自然是运行的越快越好。但是这受到了几方面的影响。其中之一便是花费在垃圾回收上的时间应当越少越好，通常用`标记/构造率`来衡量这一指标，它表示回收器与赋值器的活跃度的比值。然而在大多数良性设计中，赋值器会占用更多的CPU时间，所以适当的在牺牲回收器基础上提升赋值器的吞吐量，并进一步提升整个程序的执行速度（赋值器+回收器）一般来说是值得的。

#### 完整性与及时性

理想情况下，垃圾回收应当是完整的，即堆中所有垃圾都被回收。但这通常是不现实的。从性能方面考虑，一次回收过程中只处理堆中部分对象更加合理。

在并发垃圾回收器中，由于赋值器和回收器同时工作，会出现`浮动垃圾`，即回收器开始工作后才变成垃圾，那么该对象只能在下个回收周期中进行回收。所以衡量完整性更好的方法是统计垃圾的最终回收情况而不是单个周期中的回收情况。不同算法在及时性上差异较大，需要在空间和时间上进行权衡。

#### 停顿时间

许多回收器在进行垃圾回收时需要中断赋值线程，因此会导致程序在执行过程中出现停顿。回收器应当尽量减少对程序主要执行过程的影响，因此要求停顿时间越短越好。

`并行回收器`虽然也需要停顿整个程序，但他可以通过多线程回收的策略缩短停顿时间。为进一步减少停顿时间，并发回收器与增量回收器偶尔会将部分回收工作与赋值器交替进行或者同时进行，但由于需要确保赋值器和回收器之间的同步，赋值器的额外开销将会增大。

不论如何，缩短停顿时间的措施通常会增大整体处理时间，即降低整体处理速度。

另外，仅对最大或者平均停顿时间进行度量是不够的，必须同事考虑赋值器的性能，因此停顿时间的分布情况也值得关注。通常使用`最小赋值器使用率（MMU）`和`界限赋值器使用率（BMU）`的概念，去衡量停顿时间的分布。

#### 空间开销

内存管理的目的是高效的使用内存空间。不论是显式内存管理还是自动内存管理都会产生不同程度的空间开销。

#### 针对特定语言的优化

垃圾回收算发可以根据它们所服务的不同语言范式来归类。不同种类语言可能对回收器具有不同的要求，最显著的茶艺师语言中指针功能的不同，以及回收器调用对象终结的需求不同。

#### 可扩展性和可移植性

现在硬件发展迅速，内存、处理器等方面性能越来越强，对内存管理方面也会有更多的需求。然而对可移植性实际上的需求也并不是特别的高，有则更好。

### 性能劣势

一个长期观点是，垃圾回收通常会在总内存吞吐量以及垃圾回收停顿时间方面引入一些不可接受的开销，从而导致应用程序的执行速度慢于显示内存管理。

在`Herts`等人的测试中发现，在堆足够大的情况下（达到所需最小空间的5倍），那么垃圾回收器的执行时间性能将可以与显示分配匹敌，但是对于一般大小的堆，垃圾回收的开销会平均增大17%。
